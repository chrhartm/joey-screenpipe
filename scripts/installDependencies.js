// TODO:
// - Better error handling by using 'finally' blocks to clean up
// - Download 7-Zip on Windows if not already installed (maybe use the 7zip NPM package)
// - Remove extra files not used generated by this script such as vc_redist.arm64
// - Use only the tar NPM package instead of the tar command

import { $ } from "bun";
import fs from "fs/promises";
import {
	mkdirSync,
	existsSync,
	renameSync,
	rmSync,
	createWriteStream,
	unlinkSync,
	writeFileSync,
} from "fs";
import os from "os";
import path from "path";
import { config as dotEnv } from "dotenv";
import { finished } from "stream/promises";
import { Readable } from "stream";
import { extract as tarExtract } from "tar";
import zipExtract from "extract-zip";
dotEnv({ path: path.join(import.meta.dirname, ".pub.env") });

process.chdir(path.join(import.meta.dirname, "../src-tauri"));
const cwd = process.cwd();
const binDir = path.join(cwd, "bin");

if (!existsSync(binDir)) {
	mkdirSync(binDir);
}

async function download(url, path) {
	const res = await fetch(url);
	const fileStream = createWriteStream(path, { flags: "wx" });
	return finished(Readable.fromWeb(res.body).pipe(fileStream));
}

const windowsScreenpipe = path.join(
	binDir,
	"screenpipe-x86_64-pc-windows-msvc.exe"
);
const linuxScreenpipe = path.join(
	binDir,
	"screenpipe-x86_64-unknown-linux-gnu"
);
const macScreenpipe = path.join(binDir, "screenpipe-aarch64-apple-darwin");
if (existsSync(windowsScreenpipe)) rmSync(windowsScreenpipe, { force: true });
if (existsSync(linuxScreenpipe)) rmSync(linuxScreenpipe, { force: true });
if (existsSync(macScreenpipe)) rmSync(macScreenpipe, { force: true });

const linuxTar = path.join(binDir, "screenpipe-linux.tar.gz");
const windowsZip = path.join(binDir, "screenpipe-windows.zip");
const macTar = path.join(binDir, "screenpipe-mac.tar.gz");
try {
	const linuxDownload = download(
		`https://github.com/mediar-ai/screenpipe/releases/download/v${process.env.SCREENPIPE_VERSION}/screenpipe-${process.env.SCREENPIPE_VERSION}-x86_64-unknown-linux-gnu.tar.gz`,
		linuxTar
	);
	const windowsDownload = download(
		`https://github.com/mediar-ai/screenpipe/releases/download/v${process.env.SCREENPIPE_VERSION}/screenpipe-${process.env.SCREENPIPE_VERSION}-x86_64-pc-windows-msvc.zip`,
		windowsZip
	);
	const macDownload = download(
		`https://github.com/mediar-ai/screenpipe/releases/download/v${process.env.SCREENPIPE_VERSION}/screenpipe-${process.env.SCREENPIPE_VERSION}-aarch64-apple-darwin.tar.gz`,
		macTar
	);
	await Promise.all([linuxDownload, windowsDownload, macDownload]);

	await tarExtract({
		file: linuxTar,
		cwd: binDir,
	});
	renameSync(
		path.join(binDir, "bin", "screenpipe"),
		path.join(binDir, "screenpipe-x86_64-unknown-linux-gnu")
	);

	await zipExtract(windowsZip, { dir: binDir });
	renameSync(
		path.join(binDir, "bin", "screenpipe.exe"),
		path.join(binDir, "screenpipe-x86_64-pc-windows-msvc.exe")
	);

	await tarExtract({
		file: macTar,
		cwd: binDir,
	});
	renameSync(
		path.join(binDir, "bin", "screenpipe"),
		path.join(binDir, "screenpipe-aarch64-apple-darwin")
	);
} finally {
	if (existsSync(linuxTar)) {
		rmSync(linuxTar, { force: true, recursive: true });
	}
	if (existsSync(windowsZip)) {
		rmSync(windowsZip, { force: true, recursive: true });
	}
	if (existsSync(macTar)) {
		rmSync(macTar, { force: true, recursive: true });
	}
	if (existsSync(path.join(binDir, "bin"))) {
		rmSync(path.join(binDir, "bin"), { force: true, recursive: true });
	}
}

const platform = {
	win32: "windows",
	darwin: "macos",
	linux: "linux",
}[os.platform()];

const config = {
	ffmpegRealname: "ffmpeg",
	windows: {
		ffmpegName: "ffmpeg-7.0.2-full_build-shared",
		ffmpegUrl:
			"https://www.gyan.dev/ffmpeg/builds/packages/ffmpeg-7.0.2-full_build-shared.7z",
	},
	linux: {
		aptPackages: [
			"tesseract-ocr",
			"libtesseract-dev",
			"ffmpeg",
			"pkg-config",
			"build-essential",
			"libglib2.0-dev",
			"libgtk-3-dev",
			"libwebkit2gtk-4.1-dev",
			"clang",
			"cmake",
			"libavutil-dev",
			"libavformat-dev",
			"libavfilter-dev",
			"libavdevice-dev",
			"libasound2-dev",
			"libxdo-dev",
		],
	},
	macos: {
		ffmpegName: "ffmpeg-7.0-macOS-default",
		ffmpegUrl:
			"https://master.dl.sourceforge.net/project/avbuild/macOS/ffmpeg-7.0-macOS-default.tar.xz?viasf=1",
	},
};

if (platform == "linux") {
	try {
		await $`sudo apt-get update`;

		for (const name of config.linux.aptPackages) {
			await $`sudo apt-get install -y ${name}`;
		}
	} catch (error) {
		console.error("error installing apps via apt, %s", error.message);
	}
}

if (platform == "windows") {
	if (!existsSync(config.ffmpegRealname)) {
		await download(
			config.windows.ffmpegUrl,
			path.join(binDir, `${config.windows.ffmpegName}.7z`)
		);
		await $`'C:\\Program Files\\7-Zip\\7z.exe' x ${path.join(
			binDir,
			config.windows.ffmpegName
		)}.7z -o${binDir} `;
		await $`mv ${path.join(binDir, config.windows.ffmpegName)} ${path.join(
			binDir,
			config.ffmpegRealname
		)}`;
		await $`rm -rf ${path.join(binDir, config.windows.ffmpegName)}.7z`;
	}
	// Install ONNX
	await installOnnxRuntime();
}

if (platform == "macos") {
	// Define the destination ffmpeg path inside the bin directory.
	const ffmpegDestPath = path.join(binDir, config.ffmpegRealname);

	// Check if ffmpeg hasn't already been installed in binDir.
	if (!existsSync(ffmpegDestPath)) {
		// Download the tar.xz archive of ffmpeg.
		await download(
			config.macos.ffmpegUrl,
			path.join(binDir, `${config.macos.ffmpegName}.tar.xz`)
		);
		
		// Extract the archive directly into binDir.
		await $`tar -C ${binDir} xf ${path.join(binDir, `${config.macos.ffmpegName}.tar.xz`)}`;

		// In case a previous ffmpeg destination exists, remove it.
		if (existsSync(ffmpegDestPath)) {
			console.log("Removing existing ffmpeg folder at:", ffmpegDestPath);
			rmSync(ffmpegDestPath, { recursive: true, force: true });
		}

		// Rename (move) the extracted folder from its default name to the target ffmpeg directory.
		await $`mv ${path.join(binDir, config.macos.ffmpegName)} ${ffmpegDestPath}`;
		
		// Clean up the downloaded archive.
		await $`rm ${path.join(binDir, `${config.macos.ffmpegName}.tar.xz`)}`;
	} else {
		console.log("FFMPEG already exists at", ffmpegDestPath);
	}

	console.log("Moved and renamed ffmpeg binary for externalBin");

	console.log("Setting up Swift UI monitoring...");
	try {
		// Define the full file path for the swift source file.
		const swiftFilePath = path.join(binDir, "..", "temp", "ui_monitoring_macos.swift");

		// Ensure the directory exists (i.e. the parent folder for the swift file).
		mkdirSync(path.dirname(swiftFilePath), { recursive: true });

		// Remove the Swift file if it already exists to avoid an "EEXIST" error.
		if (existsSync(swiftFilePath)) {
			console.log(`Deleting existing Swift file at ${swiftFilePath}`);
			unlinkSync(swiftFilePath);
		}

		// Download the Swift file into swiftFilePath.
		await download(
			`https://raw.githubusercontent.com/mediar-ai/screenpipe/refs/tags/v${process.env.SCREENPIPE_VERSION}/screenpipe-vision/src/ui_monitoring_macos.swift`,
			swiftFilePath
		);

		const architectures = ["arm64", "x86_64"];
		for (const arch of architectures) {
			console.log(`Compiling Swift UI monitor for ${arch}...`);
			const binaryName = `ui_monitor-${arch === "arm64" ? "aarch64" : "x86_64"}-apple-darwin`;
			const outputPath = path.join(binDir, binaryName);

			await $`swiftc -O -whole-module-optimization -enforce-exclusivity=unchecked -num-threads 8 -target ${arch}-apple-macos11.0 -o ${outputPath} ${swiftFilePath} -framework Cocoa -framework ApplicationServices -framework Foundation`;

			console.log(`Swift UI monitor for ${arch} compiled successfully`);
			await fs.chmod(outputPath, 0o755);
		}
	} catch (error) {
		console.error("Error setting up Swift UI monitoring:", error);
		throw error;
	}
}

async function installOnnxRuntime() {
	const url =
		"https://github.com/microsoft/onnxruntime/releases/download/v1.19.2/onnxruntime-win-x64-gpu-1.19.2.zip";
	const fileName = "onnxruntime-win-x64-gpu-1.19.2.zip";
	const zipPath = path.join(binDir, fileName);

	await download(url, zipPath);
	await zipExtract(zipPath, { dir: path.join(binDir, "..", "lib") });

	rmSync(zipPath);
}

async function installOllamaSidecar() {
	const ollamaVersion = "v0.3.14";

	let ollamaExe, ollamaUrl;

	if (platform === "windows") {
		ollamaExe = "ollama-x86_64-pc-windows-msvc.exe";
		ollamaUrl = `https://github.com/ollama/ollama/releases/download/${ollamaVersion}/ollama-windows-amd64.zip`;
	} else if (platform === "macos") {
		ollamaUrl = `https://github.com/ollama/ollama/releases/download/${ollamaVersion}/ollama-darwin`;
	} else if (platform === "linux") {
		ollamaExe = "ollama-x86_64-unknown-linux-gnu";
		ollamaUrl = `https://github.com/ollama/ollama/releases/download/${ollamaVersion}/ollama-linux-amd64.tgz`;
	} else {
		throw new Error("Unsupported platform");
	}

	if (
		(platform === "macos" &&
			existsSync(path.join(binDir, "ollama-aarch64-apple-darwin")) &&
			existsSync(path.join(binDir, "ollama-x86_64-apple-darwin"))) ||
		(platform !== "macos" && existsSync(path.join(binDir, ollamaExe)))
	) {
		console.log("ollama sidecar already exists. skipping installation.");
		return;
	}

	try {
		await fs.mkdir(binDir, { recursive: true });
		const downloadPath = path.join(binDir, path.basename(ollamaUrl));

		console.log("Downloading Ollama...");
		await download(ollamaUrl, downloadPath);

		console.log("Extracting Ollama...");
		if (platform === "windows") {
			await $`powershell -command "Expand-Archive -Path '${downloadPath}' -DestinationPath '${path.join(
				binDir,
				".."
			)}'"`;
			await fs.rename(
				path.join(binDir, "..", "ollama.exe"),
				path.join(binDir, ollamaExe)
			);
		} else if (platform === "linux") {
			await $`tar -xzf "${downloadPath}" -C "${binDir}"`;
			await fs.rename(
				path.join(binDir, "bin/ollama"),
				path.join(binDir, ollamaExe)
			);
			await fs.rename(
				path.join(binDir, "lib"),
				path.join(binDir, "..", "lib")
			);
		} else if (platform === "macos") {
			await fs.copyFile(
				downloadPath,
				path.join(binDir, "ollama-aarch64-apple-darwin")
			);
			await fs.copyFile(
				downloadPath,
				path.join(binDir, "ollama-x86_64-apple-darwin")
			);
		}

		console.log("Setting permissions...");
		if (platform === "linux") {
			await fs.chmod(path.join(binDir, ollamaExe), "755");
		} else if (platform === "macos") {
			await fs.chmod(
				path.join(binDir, "ollama-aarch64-apple-darwin"),
				"755"
			);
			await fs.chmod(
				path.join(binDir, "ollama-x86_64-apple-darwin"),
				"755"
			);
		}

		console.log("Cleaning up...");
		if (platform !== "macos") {
			await fs.unlink(downloadPath);
		}
		if (platform === "linux") {
			await fs.rmdir(path.join(binDir, "bin"), { recursive: true });
		}

		if (platform === "windows") {
			const libDir = path.join("lib", "ollama");
			const oldLibs = [
				"cublas64_11.dll",
				"cublasLt64_11.dll",
				"cudart64_110.dll",
				"ggml_cuda_v11.dll",
				"rocblas",
				"rocblas.dll",
				"ggml_rocm.dll",
			];

			for (const lib of oldLibs) {
				try {
					const libPath = path.join(libDir, lib);
					const stat = await fs.stat(libPath);
					if (stat.isDirectory()) {
						await fs.rm(libPath, { recursive: true, force: true });
					} else {
						await fs.unlink(libPath);
					}
					console.log(`removed old library: ${lib}`);
				} catch (error) {
					console.warn(`failed to remove ${lib}:`, error.message);
				}
			}
		}

		console.log("ollama sidecar installed successfully");
	} catch (error) {
		console.error("error installing ollama sidecar:", error);
		throw error;
	}
}

async function copyBunBinary() {
	console.log("checking bun binary for tauri...");

	let bunSrc, bunDest1, bunDest2;
	if (platform === "windows") {
		const npmGlobalPrefix = (await $`npm config get prefix`.text()).trim();
		console.log("npm global prefix:", npmGlobalPrefix);

		let bunPathFromSystem;
		try {
			bunPathFromSystem = (await $`where.exe bun`.text())
				.trim()
				.split("\n")[0];
		} catch {
			try {
				bunPathFromSystem = (await $`which bun`.text()).trim();
			} catch {
				console.log("could not find bun using where.exe or which");
			}
		}

		if (bunPathFromSystem) {
			console.log("found bun using system command at:", bunPathFromSystem);
		}

		const possibleBunPaths = [
			bunPathFromSystem,
			path.join(os.homedir(), ".bun", "bin", "bun.exe"),
			path.join(npmGlobalPrefix, "node_modules", "bun", "bin", "bun.exe"),
			path.join(npmGlobalPrefix, "bun.exe"),
			path.join(npmGlobalPrefix, "bin", "bun.exe"),
			path.join(os.homedir(), "AppData", "Local", "bun", "bun.exe"),
			"C:\\Program Files\\bun\\bun.exe",
			"C:\\Program Files (x86)\\bun\\bun.exe",
			"bun.exe",
		].filter(Boolean);

		console.log("searching bun in these locations:");
		possibleBunPaths.forEach((p) => console.log("- " + p));

		bunSrc = null;
		for (const possiblePath of possibleBunPaths) {
			try {
				await fs.access(possiblePath);
				console.log("found bun at:", possiblePath);
				bunSrc = possiblePath;
				break;
			} catch {
				continue;
			}
		}

		if (!bunSrc) {
			throw new Error(
				"Could not find bun.exe in any expected location. Please check if bun is installed correctly"
			);
		}

		bunDest1 = path.join(binDir, "bun-x86_64-pc-windows-msvc.exe");
		console.log("copying bun from:", bunSrc);
		console.log("copying bun to:", bunDest1);
	} else if (platform === "macos") {
		// Try to locate bun using `which bun`.
		let bunFromSystem = "";
		try {
			bunFromSystem = (await $`which bun`.text()).trim();
			if (bunFromSystem) {
				console.log("Found bun via `which bun` at:", bunFromSystem);
			}
		} catch (err) {
			console.warn("Error running which bun:", err);
		}
		// Fallback to the default location if not found
		bunSrc = bunFromSystem || path.join(os.homedir(), ".bun", "bin", "bun");
		bunDest1 = path.join(binDir, "bun-aarch64-apple-darwin");
		bunDest2 = path.join(binDir, "bun-x86_64-apple-darwin");
	} else if (platform === "linux") {
		let bunFromSystem = "";
		try {
			bunFromSystem = (await $`which bun`.text()).trim();
			if (bunFromSystem) {
				console.log("Found bun via `which bun` at:", bunFromSystem);
			}
		} catch (err) {
			console.warn("Error running which bun:", err);
		}
		bunSrc = bunFromSystem || path.join(os.homedir(), ".bun", "bin", "bun");
		bunDest1 = path.join(binDir, "bun-x86_64-unknown-linux-gnu");
	}

	if (existsSync(bunDest1)) {
		console.log("bun binary already exists for tauri.");
		return;
	}

	try {
		await fs.access(bunSrc);
		await copyFile(bunSrc, bunDest1);
		console.log(
			`bun binary copied successfully from ${bunSrc} to ${bunDest1}`
		);

		if (platform === "macos") {
			await copyFile(bunSrc, bunDest2);
			console.log(`bun binary also copied to ${bunDest2}`);
		}
	} catch (error) {
		console.error("failed to copy bun binary:", error);
		console.error("source path:", bunSrc);
		process.exit(1);
	}
}

async function copyFile(src, dest) {
	await fs.copyFile(src, dest);
	await fs.chmod(dest, 0o755);
}

await copyBunBinary();
await installOllamaSidecar().catch(console.error);

/**
 * Ensures that the directory for a given file path exists,
 * then writes the content to that file.
 *
 * @param {string} filePath - The full file path where the content should be written.
 * @param {string} content - The content to write to the file.
 */
function writeSwiftFile(filePath, content) {
	// Get the parent directory of the file
	const dir = path.dirname(filePath);

	// Check if the directory exists; if not, create it recursively.
	if (!existsSync(dir)) {
		mkdirSync(dir, { recursive: true });
	}

	// Write the file content
	writeFileSync(filePath, content, "utf8");
}

// Example usage:
const swiftFilePath = "/Users/christoph/repos/joey-screenpipe/src-tauri/temp/ui_monitoring_macos.swift";
const swiftContent = "// Swift code goes here";

writeSwiftFile(swiftFilePath, swiftContent);
